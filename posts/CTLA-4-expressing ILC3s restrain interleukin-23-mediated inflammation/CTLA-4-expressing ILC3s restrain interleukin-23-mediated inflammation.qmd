---
title: "Figs 3k, 5c -- CTLA-4-expressing ILC3s restrain interleukin-23-mediated inflammation"
author: "Jeff Walker"
date: '5 July 2024'
date-modified: "`r Sys.Date()`"
categories: ["percents", "proportions", "generalized linear model", "power", "simulation"]
description: ""
draft: true
format: 
  html: 
    toc: true 
    toc-location: right
execute: 
  message: false
  warning: false
editor_options: 
  chunk_output_type: inline
freeze: false
---

![xxx](../../figs/CTLA-4-expressing ILC3s restrain interleukin-23-mediated inflammation/xxx.png){width=6in fig-align="left"}

## Vital info

Data From: [Ahmed, A., Joseph, A. M., Zhou, J., Horn, V., Uddin, J., Lyu, M., ... & Sonnenberg, G. F. (2024). CTLA-4-expressing ILC3s restrain interleukin-23-mediated inflammation. Nature, 1-8.](https://www.nature.com/articles/s41586-024-07537-3){target="_blank"}

Fig: 3k [download data](../../data from/CTLA-4-expressing ILC3s restrain interleukin-23-mediated inflammation/41586_2024_7537_MOESM6_ESM.xlsx){target="_blank"}

Fig: 5c [download data](../../data from/CTLA-4-expressing ILC3s restrain interleukin-23-mediated inflammation/41586_2024_7537_MOESM8_ESM.xlsx){target="_blank"}

key words: 

Published methods: one-way ANOVA with Tukey adjustment

Design: Completely Randomized Design with subsampling (CRDS)

Response: mRNA level

Key learning concepts: not adjusting for multiple p-values, CIs that go below zero

More info: [Chapter 16 Models for non-independence -- linear mixed models](https://www.middleprofessor.com/files/applied-biostatistics_bookdown/_book/lmm){target="_blank"}

## The Experiment

Dexamethasone (DEX) is a synthetic glucocortacoid hormone used to treat inflammation and chronic autoimmune diseases but it also stimulates muscle atrophy. The authors are investigating the role of interactions between Lysine-specific demethylase 1 (LSD1) and the glucocortacoid recepter (GCR) in the development of muscle atrophy.

Earlier experiments presented in the paper show evidence that atrophy is mediated by a LSD1/GCR complex that regulates genes related to atrophy and other pathways. For this experiment, mice were treated with a combination of DEX and the LSD1-specific inhibitor CC-90011. Here the researchers are looking at the effect of the different treatment combinations on RNA expression of genes related to the ubiquitin-proteasome system (Fbxo32, Trim63) and the autophagy system (Atg7, Becn1, Bnip3).

Treatment levels

1. Vehicle (Dex-/CC-) Expected to have low levels of target gene expression
2. Dex (Dex+/CC-)     Positive control. Expected to have elevated levels of target gene expression relative to vehicle
3. CC (Dex-/CC+)      Important negative control. We expect this to be similar to Vehicle. If it is not, we need the interaction.
4. DEX+CC (Dex+/CC+)  If LSD1 works with the GCR as expected, then we expect these levels to be lower than Dex+/CC- but how much depends on CC concentration.

Analysis Flag: The data are two technical replicates per mouse, so all inference will be a little optimistic. The mouse ID was not archived so I cannot better-than-reproduce the results.

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# wrangling packages
library(here) # here makes a project transportable
library(janitor) # clean_names
library(readxl) # read excel, duh!
library(writexl) # write excel, duh!
library(data.table) # magical data frames
library(magrittr) # pipes
library(stringr) # string functions
library(forcats) # factor functions

# analysis packages
library(emmeans) # the workhorse for inference
library(nlme) # gls and some lmm
library(lme4) # linear mixed models
library(lmerTest) # linear mixed model inference
library(afex) # ANOVA linear models
library(glmmTMB) # generalized linear models
library(MASS) # negative binomial and some other functions
library(car) # model checking and ANOVA
library(DHARMa) # model checking
library(mvtnorm)
library(MHTdiscrete) # sidak

# graphing packages
library(ggsci) # color palettes
library(ggpubr) # publication quality plots
library(ggforce) # better jitter
library(cowplot) # combine plots
library(knitr) # kable tables
library(kableExtra) # kable_styling tables

# ggplot_the_model.R packages not loaded above
library(insight)
library(lazyWeave)

# use here from the here package
here <- here::here
# use clean_names from the janitor package
clean_names <- janitor::clean_names
# use transpose from data.table
transpose <- data.table::transpose

# load functions used by this text written by me
# ggplot_the_model.R needs to be in the folder "R"
# if you didn't download this and add to your R folder in your
# project, then this line will cause an error
source_path <- here("R", "ggplot_the_model.R")
source(source_path)
source_path <- here("R", "ggptm.R")
source(source_path)

data_folder <- "data from"
image_folder <- "images"
output_folder <- "output"
```

## Import and Wrangle


```{r fig-5c-import, message=FALSE, warning=FALSE}
data_from <- "CTLA-4-expressing ILC3s restrain interleukin-23-mediated inflammation"
file_name <- "41586_2024_7537_MOESM8_ESM.xlsx"
file_path <- here(data_folder, data_from, file_name)

health_levels <- c("Healthy", "IBD")
fig5c <- read_excel(file_path,
                    sheet = "Fig. 5c",
                    range = "F5:G25",
                    col_names = TRUE) |>
  data.table() |>
  melt(variable.name = "health", value.name = "ctla4_pos")
fig5c[, health := factor(health, levels = health_levels)]


file_out_name <- "Fig5c-proportion - CTLA-4-expressing ILC3s restrain interleukin-23-mediated inflammation.xlsx"
fileout_path <- here(data_folder, data_from, file_out_name)
write_xlsx(fig5c, fileout_path)

```

## Reproducibility

```{r}
wilcox.test(ctla4_pos ~ health, data = fig5c)
```

## LM

```{r}
m1 <- lm(ctla4_pos ~ health, data = fig5c)
m1_emm <- emmeans(m1, specs = "health")
m1_pairs <- contrast(m1_emm, method = "revpairwise") |>
  summary(infer = TRUE)
m1_pairs |>
  kable() |>
  kable_styling()

```
```{r}
ggcheck_the_model(m1)
```

## GLM for percent (proportion of whole) data

```{r}
fig5c[, ctla4_prop := ctla4_pos/100]
m2 <- glm(ctla4_prop ~ health,
          family = quasibinomial,
          data = fig5c)
m2_emm <- emmeans(m2, specs = "health")
m2_pairs <- contrast(m2_emm, method = "revpairwise") |>
  summary(infer = TRUE)
m2_pairs |>
  kable() |>
  kable_styling()
```

## Should I use Mann-Whitney, a Linear Model, or a Quasibinomial GLM for propotion data?



## For these data, the Linear/ANOVA model has more power than a Negative-Binomial GLM

Despite the violations, tests from linear/ANOVA models that give a *p*-value often have good long-run performance, that is, they have relatively high power and controlled type I error [Ives 2015](https://besjournals.onlinelibrary.wiley.com/doi/abs/10.1111/2041-210X.12386){target="_blank"}. GLM models for count data can have higher power than a linear/ANOVA model, but this sometimes requires some more sophisticated methods such as bootstrap resampling [Warton et al. 2016](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12552){target="_blank"}.

Here I use a simulation to compare the Type I error and Power of the Linear/ANOVA model and for a Negative Binomial GLM for data that look like those in Figure 7d. I explicitly simulate the Trim63 response with the same unbalanced data as in the experiment (the CC group only has 9 measures and not 10).

```{r, eval = TRUE}
# get parameters
do_it <- FALSE
if(do_it){
  data_params <- fig7d[, .(mean = mean(Trim63),
                           N = .N), by = "treatment"]
  mu <- rep(data_params$mean, data_params$N)
  N <- sum(data_params$N)
  m1 <- glm.nb(Trim63 ~ dex * cc, data = fig7d)
  theta_sim <- m1$theta
  
  n_sim <- 2000
  fd <- data.table(
    treatment = rep(c("veh", "dex", "dex_cc", "cc"), data_params$N),
    dex = rep(c("no_dex", "dex", "dex", "no_dex"), data_params$N),
    cc = rep(c("no_cc", "no_cc", "cc", "cc"), data_params$N),
    Trim63 = as.numeric(NA)
  )
  
  # power
  power_matrix <- matrix(nrow = n_sim, ncol = 4)
  colnames(power_matrix) <- c("lm_focal", "lm_ixn", "glm_focal", "glm_ixn")
  for(sim_i in 1:n_sim){
    # fake data
    fd[, Trim63 := rnegbin(N, mu, theta_sim)]
    
    # lm/ANOVA
    m_lm <- lm(Trim63 ~ dex * cc, data = fd)
    power_matrix[sim_i, "lm_ixn"] <- coef(summary(m_lm))["dexno_dex:ccno_cc", "Pr(>|t|)"]
    m_lm_pairs <- emmeans(m_lm, specs = c("dex", "cc")) |>
      contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
      summary(infer = TRUE)
    power_matrix[sim_i, "lm_focal"] <- m_lm_pairs[3, "p.value"] # effect of CC when dex is present
    
    # glm neg bin
    m_glm <- glm.nb(Trim63 ~ dex * cc, data = fd)
    power_matrix[sim_i, "glm_ixn"] <- coef(summary(m_glm))["dexno_dex:ccno_cc", "Pr(>|z|)"]
    m_glm_pairs <- emmeans(m_glm, specs = c("dex", "cc")) |>
      contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
      summary(infer = TRUE)
    power_matrix[sim_i, "glm_focal"] <- m_glm_pairs[3, "p.value"] # effect of CC when dex is present
  }
  
  
  # type I
  type1_matrix <- matrix(nrow = n_sim, ncol = 4)
  colnames(type1_matrix) <- c("lm_focal", "lm_ixn", "glm_focal", "glm_ixn")
  for(sim_i in 1:n_sim){
    # fake data
    fd[, Trim63 := rnegbin(N, mu[1], theta_sim)]
    
    # lm/ANOVA
    m_lm <- lm(Trim63 ~ dex * cc, data = fd)
    type1_matrix[sim_i, "lm_ixn"] <- coef(summary(m_lm))["dexno_dex:ccno_cc", "Pr(>|t|)"]
    m_lm_pairs <- emmeans(m_lm, specs = c("dex", "cc")) |>
      contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
      summary(infer = TRUE)
    type1_matrix[sim_i, "lm_focal"] <- m_lm_pairs[3, "p.value"] # effect of CC when dex is present
    
    # glm neg bin
    m_glm <- glm.nb(Trim63 ~ dex * cc, data = fd)
    type1_matrix[sim_i, "glm_ixn"] <- coef(summary(m_glm))["dexno_dex:ccno_cc", "Pr(>|z|)"]
    m_glm_pairs <- emmeans(m_glm, specs = c("dex", "cc")) |>
      contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
      summary(infer = TRUE)
    type1_matrix[sim_i, "glm_focal"] <- m_glm_pairs[3, "p.value"] # effect of CC when dex is present
  }
  saveRDS(power_matrix, "power_matrix.Rds")
  saveRDS(type1_matrix, "type1_matrix.Rds")
}else{
  power_matrix <- readRDS("power_matrix.Rds")
  type1_matrix <- readRDS("type1_matrix.Rds")
}

pless <- function(x){
  stat <- sum(x < 0.05)/length(x)
  return(stat)
}

res <- data.table(
  Test = c("LM: DEX+CC - DEX", "LM: Interaction", "GLM: DEX+CC - DEX", "GLM: Interaction"),
  Power = apply(power_matrix, 2, pless),
  "Type I" = apply(type1_matrix, 2, pless)
)
res |>
  kable() |>
  kable_styling(full_width = FALSE)
```

Curious. The linear model with an untransformed response has better Type I control and slightly more power than a negative binomial GLM.

That said, I really like the GLM for two reasons:

1. The effect is a multiple of the reference, which is a really meaningful way of comparing responses (for example, looking at the table below, the effect is 6.5, meaning the expression level is 6.5 times larger than that of Vehicle)
2. The CIs of the means are asymmetric, which reflects the skewed distribution of the data. This also avoids absurd CIs such as a negative lower bound (counts can't be negative!).


## Let's plot the model for all genes

```{r, fig.height = 11, fig.width= 8}
get_model_result <- function(gene_i){
  model_formula <- paste(gene_i, "~ treatment") |>
    as.formula()
  m1 <- glm.nb(model_formula, data = fig7d)
  m1_emm <- emmeans(m1, specs = c("treatment"), type = "response")
  m1_pairs <- contrast(m1_emm,
                       method = focal_contrasts,
                       adjust = "none") |>
    summary(infer = TRUE)
  return(list(m1 = m1, m1_emm = m1_emm, m1_pairs = m1_pairs))
}

res1 <- get_model_result("Fbxo32")
gg1 <- plot_response(res1$m1, res1$m1_emm, res1$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
                     x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"))
res2 <- get_model_result("Trim63")
gg2 <- plot_response(res2$m1, res2$m1_emm, res2$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
                     x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"))
res3 <- get_model_result("Atg7")
gg3 <- plot_response(res3$m1, res3$m1_emm, res3$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
                     x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"))
res4 <- get_model_result("Becn1")
gg4 <- plot_response(res4$m1, res4$m1_emm, res4$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
                     x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"))
res5 <- get_model_result("Bnip3")
gg5 <- plot_response(res5$m1, res5$m1_emm, res5$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
                     x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"))

plot_grid(gg1, gg2, gg3, gg4, gg5, nrow = 3)
# gg1
# gg2
# gg3
# gg4
# gg5
```


