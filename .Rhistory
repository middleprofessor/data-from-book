# gg2
# gg3
# gg4
# gg5
# the researcher's analysis
m0 <- lm(Fbxo32 ~ treatment, data = fig7d)
m0_emm <- emmeans(m0, c("treatment"))
m0_pairs <- contrast(m0_emm,
method = "revpairwise",
adjust = "tukey") |>
summary(infer = TRUE)
# the analysis only comparing the families of tests that we care about
veh = c(1, 0, 0, 0)
dex = c(0, 1, 0, 0)
dex_cc = c(0, 0, 1, 0) # note the wonky ordering in fig 7d
cc = c(0,0,0,1)
focal_contrasts = list(
"DEX - Vehicle" = dex - veh,
"CC - Vehicle" = cc - veh,
"DEX+CC - DEX" = dex_cc - dex,
"interaction" = (dex_cc - dex) - (cc - veh)
)
m1 <- lm(Fbxo32 ~ treatment, data = fig7d)
m1_emm <- emmeans(m1, c("treatment"))
m1_pairs <- contrast(m1_emm,
method = focal_contrasts,
adjust = "none") |>
summary(infer = TRUE)
contrast_table <-
rbind(m0_pairs, m1_pairs)
contrast_table |>
kable(digits = 4) |>
kable_styling() |>
pack_rows("Adjusted", 1, 6) |>
pack_rows("Non-adjusted", 7, 10)
plot_response(m1, m1_emm, m1_pairs[1:3,])
m1_pairs
plot_response(m1,
m1_emm,
m1_pairs[1:3,],
palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX-\nCC+", "DEX+\nCC+"))
plot_response <- function(m1,
m1_emm,
m1_pairs,
m1_pairs_rows = NA,
join_blocks = FALSE,
show_nest_data = FALSE,
block_id = NA, # this is the column containing the blocks
nest_id = NA, # this is the column containing the cluster
jitter_spread = 0.8,
jitter_width = 0.2,
palette = "pal_ggplot",
x_axis_labels = NA,
y_label = NA){
# correct m1_pairs if its a list
if(!is.null(names(m1_pairs[[1]]))){
m1_pairs <- combine_contrasts(m1_pairs)
}
ptm <- get_ptm_parameters(m1, m1_pairs)
ptm$show_nest <- show_nest_data
if(!is.na(nest_id)){ptm$nest_id <- nest_id}
if(is.na(y_label)){y_label <- ptm$response_label}
gg_data <- create_plot_data(m1, ptm)
gg_emm <- create_emm_data(m1_emm, ptm)
ptm$plot_factor_levels <- gg_emm[, plot_factor] |> as.character()
gg_pairs <- create_pairs_data(m1_pairs, ptm)
if(!is.na(nest_id)){
gg_nest <- create_nest_data(m1, gg_data, ptm)
}else{
gg_nest <- NA
}
gg_pairs <- add_y_pos(gg_pairs, gg_data, gg_emm, gg_nest, ptm)
if(any(is.na(x_axis_labels)) == TRUE){x_axis_labels <- levels(gg_data$plot_factor)}
gg <- ggplot(data = gg_data,
aes(x = plot_factor_id,
y = y))
# add nested data
if(ptm$nested == TRUE){
# nested reps
if(show_nest_data == TRUE){
gg <- gg +
geom_sina(data = gg_data,
aes(x = plot_factor_id,
y = y,
alpha = 1),
scale = "width",
maxwidth = jitter_width,
size = 2,
color = "gray",
show.legend = FALSE)
}
}
# join blocks
if(ptm$blocked == TRUE & join_blocks == TRUE){
gg <- gg +
geom_line(data = gg_data,
aes(x = plot_factor_id,
y = y,
group = get(ptm$block_id)),
color = "grey"
)
}
if(ptm$nested == FALSE){
# experimental reps
gg <- gg +
geom_jitter(data = gg_data,
aes(x = plot_factor_id,
y = y,
color = factor_1),
width = jitter_width,
size = 4,
show.legend = FALSE)
}
# add nest means = experimental reps
if(ptm$nested == TRUE){
gg <- gg +
geom_jitter(data = gg_nest,
aes(x = plot_factor_id,
y = nest_mean,
color = factor_1),
width = jitter_width,
size = 4,
show.legend = FALSE)
}
# add model means and CI
gg <- gg +
geom_errorbar(data = gg_emm,
aes(x = plot_factor_id,
y = mean,
ymin = lo,
ymax = hi,
width =.1),
show.legend = FALSE) +
geom_point(data = gg_emm,
aes(x = plot_factor_id,
y = mean),
size = 4,
show.legend = FALSE)
# add some color
if(palette != "pal_ggplot"){
gg <- gg +
scale_color_manual(values = get(palette))
}
# add p-value brackets
gg <- gg +
stat_pvalue_manual(gg_pairs,
label = "p.print",
y.position = "y_pos",
# xmin = "minx",
# xmax = "maxx",
size = 4,
tip.length = 0.01)
# add axis labels and x-axis tick labels
gg <- gg +
ylab(y_label) +
scale_x_discrete(labels = x_axis_labels)
# add theme
gg <- gg + theme_pubr() +
theme(axis.title.x = element_blank())
# gg
return(gg)
}
plot_response(m1,
m1_emm,
m1_pairs[1:3,],
palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX-\nCC+", "DEX+\nCC+"),
NULL)
plot_response(m1,
m1_emm,
m1_pairs[1:3,],
palette = "pal_okabe_ito_blue",
#              x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX-\nCC+", "DEX+\nCC+"),
NULL)
plot_response(m1,
m1_emm,
m1_pairs[1:3,],
palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX-\nCC+", "DEX+\nCC+"),
NULL)
plot_response(m1,
m1_emm,
m1_pairs[1:3,],
palette = "pal_okabe_ito_blue",
#              x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX-\nCC+", "DEX+\nCC+"),
NULL)
m1_pairs
get_model_result <- function(gene_i){
model_formula <- paste(gene_i, "~ treatment") |>
as.formula()
m1 <- glm.nb(model_formula, data = fig7d)
m1_emm <- emmeans(m1, specs = c("treatment"), type = "response")
m1_pairs <- contrast(m1_emm,
method = focal_contrasts,
adjust = "none") |>
summary(infer = TRUE)
return(list(m1 = m1, m1_emm = m1_emm, m1_pairs = m1_pairs))
}
res1 <- get_model_result("Fbxo32")
gg1 <- plot_response(res1$m1, res1$m1_emm, res1$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX-\nCC+", "DEX+\nCC+"))
res2 <- get_model_result("Trim63")
gg2 <- plot_response(res2$m1, res2$m1_emm, res2$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX-\nCC+", "DEX+\nCC+"))
res3 <- get_model_result("Atg7")
gg3 <- plot_response(res3$m1, res3$m1_emm, res3$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX-\nCC+", "DEX+\nCC+"))
res4 <- get_model_result("Becn1")
gg4 <- plot_response(res4$m1, res4$m1_emm, res4$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX-\nCC+", "DEX+\nCC+"))
res5 <- get_model_result("Bnip3")
gg5 <- plot_response(res5$m1, res5$m1_emm, res5$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX-\nCC+", "DEX+\nCC+"))
plot_grid(gg1, gg2, gg3, gg4, gg5, nrow = 3)
# gg1
# gg2
# gg3
# gg4
# gg5
get_model_result <- function(gene_i){
model_formula <- paste(gene_i, "~ treatment") |>
as.formula()
m1 <- glm.nb(model_formula, data = fig7d)
m1_emm <- emmeans(m1, specs = c("treatment"), type = "response")
m1_pairs <- contrast(m1_emm,
method = focal_contrasts,
adjust = "none") |>
summary(infer = TRUE)
return(list(m1 = m1, m1_emm = m1_emm, m1_pairs = m1_pairs))
}
res1 <- get_model_result("Fbxo32")
gg1 <- plot_response(res1$m1, res1$m1_emm, res1$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"))
res2 <- get_model_result("Trim63")
gg2 <- plot_response(res2$m1, res2$m1_emm, res2$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"))
res3 <- get_model_result("Atg7")
gg3 <- plot_response(res3$m1, res3$m1_emm, res3$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"))
res4 <- get_model_result("Becn1")
gg4 <- plot_response(res4$m1, res4$m1_emm, res4$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"))
res5 <- get_model_result("Bnip3")
gg5 <- plot_response(res5$m1, res5$m1_emm, res5$m1_pairs[c(1,3,2),], palette = "pal_okabe_ito_blue",
x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"))
plot_grid(gg1, gg2, gg3, gg4, gg5, nrow = 3)
# gg1
# gg2
# gg3
# gg4
# gg5
gg1 <- plot_response(m1,
m1_emm,
m1_pairs[1:3,],
palette = "pal_okabe_ito_blue",
#              x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"),
NULL)
gg2 <- plot_response(m2,
m2_emm,
m2_pairs[1:3,],
palette = "pal_okabe_ito_blue",
#              x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"),
NULL)
gg1 <- plot_response(m1,
m1_emm,
m1_pairs[1:3,],
palette = "pal_okabe_ito_blue",
#              x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"),
NULL)
m2 <- glm.nb(Fbxo32 ~ treatment, data = fig7d)
m2_emm <- emmeans(m2, c("treatment"), type = "response")
m2_pairs <- contrast(m2_emm,
method = "revpairwise",
adjust = "tukey") |>
summary(infer = TRUE)
m2_pairs <- m2_pairs[, -7]
gg2 <- plot_response(m2,
m2_emm,
m2_pairs[1:3,],
palette = "pal_okabe_ito_blue",
#              x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"),
NULL)
plot_grid(gg1, gg2, ncol = 2, labels = "AUTO")
gg1 <- plot_response(m1,
m1_emm,
m1_pairs[1:3,],
palette = "pal_okabe_ito_blue",
#              x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"),
NULL)
m2 <- glm.nb(Fbxo32 ~ treatment, data = fig7d)
m2_emm <- emmeans(m2, c("treatment"), type = "response")
m2_pairs <- contrast(m2_emm,
method = focal_contrasts,
adjust = "none") |>
summary(infer = TRUE)
m2_pairs <- m2_pairs[, -7]
gg2 <- plot_response(m2,
m2_emm,
m2_pairs[1:3,],
palette = "pal_okabe_ito_blue",
#              x_axis_labels = c("DEX-\nCC-", "DEX+\nCC-", "DEX+\nCC+", "DEX-\nCC+"),
NULL)
plot_grid(gg1, gg2, ncol = 2, labels = "AUTO")
?saveRDS
# get parameters
do_it <- TRUE
if(do_it){
data_params <- fig7d[, .(mean = mean(Trim63),
N = .N), by = "treatment"]
mu <- rep(data_params$mean, data_params$N)
N <- sum(data_params$N)
m1 <- glm.nb(Trim63 ~ dex * cc, data = fig7d)
theta_sim <- m1$theta
n_sim <- 2000
fd <- data.table(
treatment = rep(c("veh", "dex", "dex_cc", "cc"), data_params$N),
dex = rep(c("no_dex", "dex", "dex", "no_dex"), data_params$N),
cc = rep(c("no_cc", "no_cc", "cc", "cc"), data_params$N),
Trim63 = as.numeric(NA)
)
# power
power_matrix <- matrix(nrow = n_sim, ncol = 4)
colnames(power_matrix) <- c("lm_focal", "lm_ixn", "glm_focal", "glm_ixn")
for(sim_i in 1:n_sim){
# fake data
fd[, Trim63 := rnegbin(N, mu, theta_sim)]
# lm/ANOVA
m_lm <- lm(Trim63 ~ dex * cc, data = fd)
power_matrix[sim_i, "lm_ixn"] <- coef(summary(m_lm))["dexno_dex:ccno_cc", "Pr(>|t|)"]
m_lm_pairs <- emmeans(m_lm, specs = c("dex", "cc")) |>
contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
summary(infer = TRUE)
power_matrix[sim_i, "lm_focal"] <- m_lm_pairs[3, "p.value"] # effect of CC when dex is present
# glm neg bin
m_glm <- glm.nb(Trim63 ~ dex * cc, data = fd)
power_matrix[sim_i, "glm_ixn"] <- coef(summary(m_glm))["dexno_dex:ccno_cc", "Pr(>|z|)"]
m_glm_pairs <- emmeans(m_glm, specs = c("dex", "cc")) |>
contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
summary(infer = TRUE)
power_matrix[sim_i, "glm_focal"] <- m_glm_pairs[3, "p.value"] # effect of CC when dex is present
}
# type I
type1_matrix <- matrix(nrow = n_sim, ncol = 4)
colnames(type1_matrix) <- c("lm_focal", "lm_ixn", "glm_focal", "glm_ixn")
for(sim_i in 1:n_sim){
# fake data
fd[, Trim63 := rnegbin(N, mu[1], theta_sim)]
# lm/ANOVA
m_lm <- lm(Trim63 ~ dex * cc, data = fd)
type1_matrix[sim_i, "lm_ixn"] <- coef(summary(m_lm))["dexno_dex:ccno_cc", "Pr(>|t|)"]
m_lm_pairs <- emmeans(m_lm, specs = c("dex", "cc")) |>
contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
summary(infer = TRUE)
type1_matrix[sim_i, "lm_focal"] <- m_lm_pairs[3, "p.value"] # effect of CC when dex is present
# glm neg bin
m_glm <- glm.nb(Trim63 ~ dex * cc, data = fd)
type1_matrix[sim_i, "glm_ixn"] <- coef(summary(m_glm))["dexno_dex:ccno_cc", "Pr(>|z|)"]
m_glm_pairs <- emmeans(m_glm, specs = c("dex", "cc")) |>
contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
summary(infer = TRUE)
type1_matrix[sim_i, "glm_focal"] <- m_glm_pairs[3, "p.value"] # effect of CC when dex is present
}
saveRDS(power_matrix, "power_matrix.Rds")
saveRDS(type1_matrix, "type1_matrix.Rds")
}else{
power_matrix <- readRDS("power_matrix.Rds")
type1_matrix <- readRDS("type1_matrix.Rds")
}
pless <- function(x){
stat <- sum(x < 0.05)/length(x)
return(stat)
}
res <- data.table(
Test = c("LM: DEX+CC - DEX", "LM: Interaction", "GLM: DEX+CC - DEX", "GLM: Interaction"),
Power = apply(power_matrix, 2, pless),
"Type I" = apply(type1_matrix, 2, pless)
)
res |>
kable() |>
kable_styling(full_width = FALSE)
# get parameters
do_it <- FALSE
if(do_it){
data_params <- fig7d[, .(mean = mean(Trim63),
N = .N), by = "treatment"]
mu <- rep(data_params$mean, data_params$N)
N <- sum(data_params$N)
m1 <- glm.nb(Trim63 ~ dex * cc, data = fig7d)
theta_sim <- m1$theta
n_sim <- 2000
fd <- data.table(
treatment = rep(c("veh", "dex", "dex_cc", "cc"), data_params$N),
dex = rep(c("no_dex", "dex", "dex", "no_dex"), data_params$N),
cc = rep(c("no_cc", "no_cc", "cc", "cc"), data_params$N),
Trim63 = as.numeric(NA)
)
# power
power_matrix <- matrix(nrow = n_sim, ncol = 4)
colnames(power_matrix) <- c("lm_focal", "lm_ixn", "glm_focal", "glm_ixn")
for(sim_i in 1:n_sim){
# fake data
fd[, Trim63 := rnegbin(N, mu, theta_sim)]
# lm/ANOVA
m_lm <- lm(Trim63 ~ dex * cc, data = fd)
power_matrix[sim_i, "lm_ixn"] <- coef(summary(m_lm))["dexno_dex:ccno_cc", "Pr(>|t|)"]
m_lm_pairs <- emmeans(m_lm, specs = c("dex", "cc")) |>
contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
summary(infer = TRUE)
power_matrix[sim_i, "lm_focal"] <- m_lm_pairs[3, "p.value"] # effect of CC when dex is present
# glm neg bin
m_glm <- glm.nb(Trim63 ~ dex * cc, data = fd)
power_matrix[sim_i, "glm_ixn"] <- coef(summary(m_glm))["dexno_dex:ccno_cc", "Pr(>|z|)"]
m_glm_pairs <- emmeans(m_glm, specs = c("dex", "cc")) |>
contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
summary(infer = TRUE)
power_matrix[sim_i, "glm_focal"] <- m_glm_pairs[3, "p.value"] # effect of CC when dex is present
}
# type I
type1_matrix <- matrix(nrow = n_sim, ncol = 4)
colnames(type1_matrix) <- c("lm_focal", "lm_ixn", "glm_focal", "glm_ixn")
for(sim_i in 1:n_sim){
# fake data
fd[, Trim63 := rnegbin(N, mu[1], theta_sim)]
# lm/ANOVA
m_lm <- lm(Trim63 ~ dex * cc, data = fd)
type1_matrix[sim_i, "lm_ixn"] <- coef(summary(m_lm))["dexno_dex:ccno_cc", "Pr(>|t|)"]
m_lm_pairs <- emmeans(m_lm, specs = c("dex", "cc")) |>
contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
summary(infer = TRUE)
type1_matrix[sim_i, "lm_focal"] <- m_lm_pairs[3, "p.value"] # effect of CC when dex is present
# glm neg bin
m_glm <- glm.nb(Trim63 ~ dex * cc, data = fd)
type1_matrix[sim_i, "glm_ixn"] <- coef(summary(m_glm))["dexno_dex:ccno_cc", "Pr(>|z|)"]
m_glm_pairs <- emmeans(m_glm, specs = c("dex", "cc")) |>
contrast(method = "revpairwise", simple = "each", combine = TRUE, adjust = "none") |>
summary(infer = TRUE)
type1_matrix[sim_i, "glm_focal"] <- m_glm_pairs[3, "p.value"] # effect of CC when dex is present
}
saveRDS(power_matrix, "power_matrix.Rds")
saveRDS(type1_matrix, "type1_matrix.Rds")
}else{
power_matrix <- readRDS("power_matrix.Rds")
type1_matrix <- readRDS("type1_matrix.Rds")
}
pless <- function(x){
stat <- sum(x < 0.05)/length(x)
return(stat)
}
res <- data.table(
Test = c("LM: DEX+CC - DEX", "LM: Interaction", "GLM: DEX+CC - DEX", "GLM: Interaction"),
Power = apply(power_matrix, 2, pless),
"Type I" = apply(type1_matrix, 2, pless)
)
res |>
kable() |>
kable_styling(full_width = FALSE)
knitr::purl("ggptm.Rmd")
packageVersion("quarto")
packageVersion("quarto")
install.packages("quarto")
knitr::opts_chunk$set(echo = TRUE)
# wrangling packages
library(here) # here makes a project transportable
library(janitor) # clean_names
library(readxl) # read excel, duh!
library(writexl) # write excel, duh!
library(data.table) # magical data frames
library(magrittr) # pipes
library(stringr) # string functions
library(forcats) # factor functions
# analysis packages
library(emmeans) # the workhorse for inference
library(nlme) # gls and some lmm
library(lme4) # linear mixed models
library(lmerTest) # linear mixed model inference
library(afex) # ANOVA linear models
library(glmmTMB) # generalized linear models
library(MASS) # negative binomial and some other functions
library(car) # model checking and ANOVA
library(DHARMa) # model checking
library(mvtnorm)
library(MHTdiscrete) # sidak
# graphing packages
library(ggsci) # color palettes
library(ggpubr) # publication quality plots
library(ggforce) # better jitter
library(cowplot) # combine plots
library(knitr) # kable tables
library(kableExtra) # kable_styling tables
# ggplot_the_model.R packages not loaded above
library(insight)
library(lazyWeave)
# use here from the here package
here <- here::here
# use clean_names from the janitor package
clean_names <- janitor::clean_names
# use transpose from data.table
transpose <- data.table::transpose
# load functions used by this text written by me
# ggplot_the_model.R needs to be in the folder "R"
# if you didn't download this and add to your R folder in your
# project, then this line will cause an error
source_path <- here("R", "ggplot_the_model.R")
source(source_path)
source_path <- here("R", "ggptm.R")
source(source_path)
data_folder <- "data from"
image_folder <- "images"
output_folder <- "output"
packageVersion("quarto")
packageVersion("quarto")
