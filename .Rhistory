)
for(iter in 1:n_iter){
b_exper <- rnorm(n_exper, mean = 0, sd = sigma_exper)
b_exper_col <- rep(rep(b_exper, each = n_dish * n_cell), n_treat)
# length(b_exper_col)
b_batch <- rnorm(t_batch, mean = 0, sd = sigma_batch)
b_batch_col <- rep(b_batch, each = n_dish * n_cell)
# length(b_batch_col)
b_dish <- rnorm(t_dish, mean = 0, sd = sigma_dish)
b_dish_col <- rep(b_dish, each = n_cell)
# length(b_dish_col)
b_cell_col <- rnorm(t_cell, mean = 0, sd = sigma_cell)
# length(b_cell_col)
# put it all together
fd[, y := b_treat_col + b_exper_col + b_batch_col + b_dish_col + b_cell_col]
# lm of raw data
m1 <- lm(y ~ treatment, data = fd)
m1_pairs <- emmeans(m1, specs = "treatment") |>
contrast(method = "revpairwise", adjust = "none") |>
summary()
p1_m1[iter] <- m1_pairs[1, "p.value"]
p2_m1[iter] <- m1_pairs[5, "p.value"]
# lm of control centered data
exper_means <- fd[, .(y_bar = mean(y)), by = .(treatment, experiment)]
y_bar_vec <- rep(rep(exper_means[1:4, y_bar], each = n_cell * n_dish), 4)
fd[, y_c := y/y_bar_vec]
# fd[, .(mean = mean(y_c),
#        sd = sd(y_c)), by = .(treatment, experiment)]
m2 <- lm(y_c ~ treatment, data = fd)
m2_pairs <- emmeans(m2, specs = "treatment") |>
contrast(method = "revpairwise", adjust = "none") |>
summary()
p1_m2[iter] <- m2_pairs[1, "p.value"]
p2_m2[iter] <- m2_pairs[5, "p.value"]
# lmm models
lmm1 <- lmer(y ~ treatment + (1 | experiment) + (1 | batch) + (1 | dish), data = fd)
lmm1_pairs <- emmeans(lmm1, specs = "treatment") |>
contrast(method = "revpairwise", adjust = "none") |>
summary()
p1_lmm1[iter] <- lmm1_pairs[1, "p.value"]
p2_lmm1[iter] <- lmm1_pairs[5, "p.value"]
# RM-ANOVA models
aov1 <- aov_4(y ~ treatment + (treatment | experiment), data = fd, fun_aggregate = mean)
aov1_pairs <- emmeans(aov1, specs = "treatment") |>
contrast(method = "revpairwise", adjust = "none") |> summary()
p1_aov1[iter] <- aov1_pairs[1, "p.value"]
p2_aov1[iter] <- aov1_pairs[5, "p.value"]
}
type_1_matrix <- rbind(
type_1_matrix,
data.table(
resid_frac = residual_frac_i,
"sigma_cell" = sigma_cell, # among cells within a dish - this is residual
"sigma_exper" = sigma_exper, # among experiments
"sigma_batch" = sigma_batch, # among batches within a treatment:experiment
"sigma_dish" = sigma_dish, # among dishes within a treatment:experiment:batch
"p1_m1" = p1_m1,
"p2_m1" = p2_m1,
"p1_m2" = p1_m2,
"p2_m2" = p2_m2,
"p1_lmm1" = p1_lmm1,
"p2_lmm1" = p2_lmm1,
# "p1_lmm2" = p1_lmm2,
# "p2_lmm2" = p2_lmm2,
"p1_aov1" = p1_aov1,
"p2_aov1" = p2_aov1
)
)
}
saveRDS(type_1_matrix, "type_1_matrix.Rds")
}else{
type_1_matrix <- readRDS("type_1_matrix.Rds")
}
resid_frac_list <- unique(type_1_matrix$resid_frac)
param_mat <- expand.grid(residual_frac = residual_frac_list)
knitr::opts_chunk$set(echo = TRUE)
# wrangling packages
library(here) # here makes a project transportable
library(janitor) # clean_names
library(readxl) # read excel, duh!
library(writexl) # write excel, duh!
library(data.table) # magical data frames
library(magrittr) # pipes
library(stringr) # string functions
library(forcats) # factor functions
# analysis packages
library(emmeans) # the workhorse for inference
library(nlme) # gls and some lmm
library(lme4) # linear mixed models
library(lmerTest) # linear mixed model inference
library(afex) # ANOVA linear models
library(glmmTMB) # generalized linear models
library(MASS) # negative binomial and some other functions
library(car) # model checking and ANOVA
library(DHARMa) # model checking
library(mvtnorm)
library(MHTdiscrete) # sidak
# graphing packages
library(ggsci) # color palettes
library(ggpubr) # publication quality plots
library(ggforce) # better jitter
library(cowplot) # combine plots
library(knitr) # kable tables
library(kableExtra) # kable_styling tables
# ggplot_the_model.R packages not loaded above
library(insight)
library(lazyWeave)
# use here from the here package
here <- here::here
# use clean_names from the janitor package
clean_names <- janitor::clean_names
# use transpose from data.table
transpose <- data.table::transpose
# load functions used by this text written by me
# ggplot_the_model.R needs to be in the folder "R"
# if you didn't download this and add to your R folder in your
# project, then this line will cause an error
source_path <- here("R", "ggplot_the_model.R")
source(source_path)
source_path <- here("R", "ggptm.R")
source(source_path)
data_folder <- "data from"
image_folder <- "images"
output_folder <- "output"
data_from <- "ER calcium depletion as a key driver for impaired ER-to-mitochondria calcium transfer and mitochondrial dysfunction in Wolfram syndrome"
file_name <- "Source data for Figures and Table.xlsx"
file_path <- here(data_folder, data_from, file_name)
fig2b <- read_excel(file_path,
sheet = "Fig 2B",
range = "A1:F138",
col_names = TRUE) |>
data.table() |>
melt(id.vars = c("experiment", "dish"),
variable.name = "treatment_id",
value.name = "er_calcium") |>
na.omit()
fig2b[treatment_id == "scr shRNA", treatment := "Control"]
fig2b[treatment_id == "Wfs1 shRNA", treatment := "Wfs1"]
fig2b[treatment_id == "RyR2 shRNA", treatment := "RyR2"]
fig2b[treatment_id == "Wfs1 shRNA + RyR2 shRNA", treatment := "Wfs1_RyR2"]
fig2b[, treatment := factor(treatment,
levels = c("Control", "Wfs1", "RyR2", "Wfs1_RyR2"))]
fig2b[, dish_id := ifelse(dish < 10, paste0("0", dish), as.character(dish))] # for plot only
fig2b[, dish := paste(treatment, dish)] # dish 1 differs in each treatment
fig2b[, experiment := as.character(experiment)] # for plot only
# output as clean excel file
# fileout_name <- "fig1c-ER calcium depletion as a key driver for impaired ER-to-mitochondria calcium transfer and mitochondrial dysfunction in Wolfram syndrome.xlsx"
# fileout_path <- here(data_folder, data_from, fileout_name)
# write_xlsx(fig1c, fileout_path)
lm1 <- lm(er_calcium ~ treatment, data = fig2b)
lm1_emm <- emmeans(lm1, specs = "treatment")
lm1_pairs <- contrast(lm1_emm,
method = "revpairwise") |>
summary(infer = TRUE)
plot_response(lm1, lm1_emm, lm1_pairs[c(1,5), ],
palette = "pal_okabe_ito_blue")
fig2b_grcbd <- fig2b[, .(er_calcium = mean(er_calcium)), by = .(experiment, dish, treatment)]
fig2b_rcbd <- fig2b_grcbd[, .(er_calcium = mean(er_calcium)), by = .(experiment, treatment)]
pd <- position_jitterdodge(dodge.width = 0.25, jitter.width = 0)
gg1 <- ggplot(data = fig2b_rcbd,
aes(x = treatment,
y = er_calcium,
color = experiment)) +
geom_point(position = pd) +
geom_line(aes(group = experiment),
position = pd,
alpha = 0.5) +
theme_pubr()
gg1
fig2b[, lm_resid := residuals(lm1)]
batch_means1 <- fig2b[, .(y = mean(lm_resid)),
by = .(treatment, experiment)]
lm2 <- lm(er_calcium ~ treatment * experiment, data = fig2b)
fig2b[, lm2_resid := residuals(lm2)]
batch_means2 <- fig2b[, .(y = mean(lm2_resid)),
by = .(treatment, experiment)]
dish_means <- fig2b[, .(y = mean(lm_resid)),
by = .(treatment, experiment, dish_id)]
ggplot(data = fig2b,
aes(x = treatment,
y = lm_resid)) +
geom_point(aes(group = dish_id, shape = experiment),
position = position_jitterdodge(jitter.width = 0),
color = "gray",
NULL
) +
geom_point(data = batch_means1,
aes(x = treatment,
y = y,
color = experiment),
position = position_jitterdodge(jitter.width = 0),
size = 3) +
geom_point(data = dish_means,
aes(x = treatment,
y = y,
group = dish_id,
color = experiment),
position = position_jitterdodge(jitter.width = 0)
) +
NULL
# (1 | experiment) - block intercept. Variance among experiments
# (1 | treatment:experiment) - treatment:experiment intercept. This is mean of batch of three dishes
# (1 | treatment:experiment:dish) - dish intercept. This is mean of 10 cells within a dish
# Residual - this is variance among cells within a dish
lmm1 <- lmer(er_calcium ~ treatment + (1 | experiment) + (1 | treatment:experiment) + (1 | treatment:experiment:dish),
data = fig2b)
var_table_1 <- VarCorr(lmm1) |> as.data.frame()
var_table_1$source = c("dish", "batch", "experiment", "cell")
var_table_1 <- var_table_1[, c(1, 6, 4, 5)]
lmm2 <- lmer(er_calcium ~ treatment + (1 | experiment) + (1 | treatment:experiment) + (1 | treatment:experiment:dish),
data = fig2b[treatment != "Control"])
var_table_2 <- VarCorr(lmm2) |> as.data.frame()
var_table_2$source = c("dish", "batch", "experiment", "cell")
var_table_2 <- var_table_2[, c(1, 6, 4, 5)]
var_table <- rbind(var_table_1, var_table_2)
var_table |>
kable(digits = 4) |>
kable_styling() |>
pack_rows("All treatments", 1, 4) |>
pack_rows("Non-control treatments", 5, 8)
icc_1 <- (var_table_1[1, "vcov"] + var_table_1[2, "vcov"]) / (var_table_1[1, "vcov"] + var_table_1[2, "vcov"] + var_table_1[3, "vcov"])
icc_1_dish <- (var_table_1[1, "vcov"]) / (var_table_1[1, "vcov"] + var_table_1[3, "vcov"])
icc_1_experiment <- (var_table_1[2, "vcov"]) / (var_table_1[2, "vcov"] + var_table_1[3, "vcov"])
icc_dish_frac_1 <- (var_table_1[1, "vcov"])/(var_table_1[1, "vcov"] + var_table_1[2, "vcov"]) # dish fraction of dish + experiment
icc_2 <- (var_table_2[1, "vcov"] + var_table_2[2, "vcov"]) / (var_table_2[1, "vcov"] + var_table_2[2, "vcov"] + var_table_2[3, "vcov"])
icc_2_dish <- (var_table_2[1, "vcov"]) / (var_table_2[1, "vcov"] + var_table_2[3, "vcov"])
icc_2_experiment <- (var_table_2[2, "vcov"]) / (var_table_2[2, "vcov"] + var_table_2[3, "vcov"])
icc_dish_frac_2 <- (var_table_2[1, "vcov"]) / (var_table_2[1, "vcov"] + var_table_2[2, "vcov"]) # dish fraction of dish + experiment
data.table(
stat = c("icc", "icc_dish", "icc_experiment", "icc_dish_frac"),
"All" = c(icc_1, icc_1_dish, icc_1_experiment, icc_dish_frac_1),
"Non-Ctl" = c(icc_2, icc_2_dish, icc_2_experiment, icc_dish_frac_2)
) |>
kable(digits = c(1, 3, 3)) |>
kable_styling(full_width = FALSE)
# (1 | experiment) - block intercept. Variance among experiments
# (1 | treatment:experiment) - treatment:experiment intercept. This is mean of batch of three dishes
# (1 | treatment:experiment:dish) - dish intercept. This is mean of 10 cells within a dish
# Residual - this is variance among cells within a dish
lmm1 <- lmer(er_calcium ~ treatment + (1 | experiment) + (1 | treatment:experiment) + (1 | treatment:experiment:dish), data = fig2b)
# aggregate dish model
lmm2 <- lmer(er_calcium ~ treatment + (1 | experiment) + (1 | treatment:experiment), data = fig2b_grcbd)
# RCBD model
lmm3 <- lmer(er_calcium ~ treatment + (1 | experiment), data = fig2b_rcbd)
lmm3_emm <- emmeans(lmm3, specs = "treatment")
lmm3_pairs <- contrast(lmm3_emm, method = "revpairwise", adjust = "none") |>
summary(infer = TRUE)
gg1 <- plot_response(lmm3, lmm3_emm, lmm3_pairs[c(1,5),],
palette = "pal_okabe_ito_blue")
aov1 <- aov_4(er_calcium ~ treatment + (treatment | experiment),
fun_aggregate = mean,
data = fig2b)
aov1_emm <- emmeans(aov1, specs = "treatment")
aov1_pairs <- contrast(aov1_emm, method = "revpairwise", adjust = "none") |>
summary(infer = TRUE)
gg2 <- plot_response(aov1, aov1_emm, aov1_pairs[c(1,5),],
palette = "pal_okabe_ito_blue")
# to show that the above does the aggregation
# aov2 <- aov_4(er_calcium ~ treatment + (treatment | experiment),
#               data = fig2b_rcbd)
# aov2_emm <- emmeans(aov2, specs = "treatment")
# aov2_pairs <- contrast(aov2_emm, method = "revpairwise", adjust = "none") |>
#   summary(infer = TRUE)
pptt_pairs <- pptt(er_calcium ~ treatment + (1 | experiment), data = fig2b_rcbd)
gg3 <- plot_response(aov1, aov1_emm, pptt_pairs[c(1,5),],
palette = "pal_okabe_ito_blue")
plot_grid(gg1, gg2, ncol = 2)
# make aov1_emm a data.table
aov1_emm_dt <- aov1_emm |>
summary() |>
data.table()
# get batch and dish means
batch_means <- fig2b[, .(y = mean(er_calcium)),
by = .(treatment, experiment)]
dish_means <- fig2b[, .(y = mean(er_calcium)),
by = .(treatment, experiment, dish_id)]
gg <- ggplot(data = fig2b,
aes(x = treatment,
y = er_calcium)) +
# raw measures
geom_point(aes(group = dish_id, color = experiment),
position = position_jitterdodge(jitter.width = 0),
size = 0.8,
alpha = 0.3,
NULL
) +
# dish means
geom_point(data = dish_means,
aes(x = treatment,
y = y,
group = dish_id,
color = experiment),
size = 1,
position = position_jitterdodge(jitter.width = 0)
) +
# batch means
geom_point(data = batch_means,
aes(x = treatment,
y = y,
color = experiment),
position = position_jitterdodge(jitter.width = 0),
size = 3) +
# treatment means
geom_point(data = aov1_emm_dt,
aes(x = treatment,
y = emmean),
color = "black",
size = 5) +
geom_errorbar(data = aov1_emm_dt,
aes(x = treatment,
y = emmean,
ymin = lower.CL,
ymax = upper.CL),
color = "black",
width = .1) +
theme_pubr() +
ylab("ER Calcium") +
theme(axis.title.x = element_blank()) +
NULL
# add p-values
aov1_pairs_dt <- aov1_pairs |>
data.table()
aov1_pairs_dt[, c("group1", "group2") := tstrsplit(contrast, " - ")]
aov1_pairs_dt[, p := paste0("p=", round(p.value, 3))]
maxy <- fig2b[, max(er_calcium)]
miny <- fig2b[, min(er_calcium)]
# show only rows 1 & 5, per the paper
aov1_pairs_1_5 <- aov1_pairs_dt[c(1,5),]
aov1_pairs_1_5[, y.position := maxy + .I*0.05*(maxy - miny)]
gg <- gg +
stat_pvalue_manual(
data = aov1_pairs_1_5,
label = "p",
tip.length = 0.01)
gg
do_it <- FALSE
set.seed(1)
type_1_matrix <- data.table(NULL)
if(do_it == TRUE){
n_iter <- 5000
n_cell <- 10
n_dish <- 3
n_exper <- 4
n_treat <- 4 # number of treatments
t_batch <- n_treat * n_exper
t_dish <- n_dish * t_batch
t_cell <- t_dish * n_cell
beta_1 <- rep(0, n_treat)
b_treat_col <- rep(beta_1, each = n_cell * n_dish * n_exper) # the fixed effects
var_table_2 <- data.table(var_table_2)
var_table_2[, frac_of_whole := vcov/sum(var_table_2[, vcov])]
var_table_2[, frac_of_modeled := vcov/sum(var_table_2[1:3, vcov])]
# unmodeled random variance is 88.8 %
# dish has 72% of modeled random variance
# batch has 0 % of modeled random variance
# experiment has 28% of modeled random variance
sigma <- 1 # this is the root variance lm(y ~ treatment)
residual_frac_list <- c(0.9, 0.95, 0.85) # fraction of random variance that is unmodeled noise
dish_frac <- .72 - 0.05/2
batch_frac <- 0.05
exp_frac <- .28 - 0.05/2
# ICC
residual_var <- residual_frac_list * sigma^2 # residual variance or variance among cells in a dish
random_var <- sigma^2 - residual_var # total random variance
exper_var <- exp_frac * random_var # variance among experiments
batch_var <- batch_frac * random_var # variance among batch of three dishes means
dish_var <- dish_frac * random_var # variance among dish means
icc <- (exper_var + batch_var + dish_var)/sigma^2
# dish_frac + batch_frac + exp_frac # check!
param_mat <- expand.grid(residual_frac = residual_frac_list) |>
data.table()
p1_m1 <- numeric(n_iter)
p2_m1 <- numeric(n_iter)
p1_m2 <- numeric(n_iter)
p2_m2 <- numeric(n_iter)
p1_lmm1 <- numeric(n_iter)
p2_lmm1 <- numeric(n_iter)
p1_aov1 <- numeric(n_iter)
p2_aov1 <- numeric(n_iter)
for(param_set in 1:nrow(param_mat)){
residual_frac_i <- param_mat[param_set, residual_frac] # fraction of random variance that is unmodeled noise
# total variance is 1
residual_var <- residual_frac_i * sigma^2 # residual variance or variance among cells in a dish
random_var <- sigma^2 - residual_var # total random variance
exper_var <- exp_frac * random_var # variance among experiments
batch_var <- batch_frac * random_var # variance among batch of three dishes means
dish_var <- dish_frac * random_var # variance among dish means
sigma_cell <- sqrt(residual_var) # among cells within a dish - this is residual
sigma_exper <- sqrt(exper_var) # among experiments
sigma_batch <- sqrt(batch_var) # among batches within a treatment:experiment
sigma_dish <- sqrt(dish_var) # among dishes within a treatment:experiment:batch
fd <- data.table(
treatment = rep(paste0("Trt", 1:n_treat), each = n_exper * n_dish * n_cell),
experiment = rep(rep(paste0("exper_", 1:n_exper), each = n_dish * n_cell), 2),
batch = rep(paste0("batch_", 1:t_batch), each = n_dish * n_cell),
dish = rep(paste0("dish_", 1:t_dish), each = n_cell),
cell = paste0("cell_", 1:t_cell),
y = rep(NA, t_cell)
)
for(iter in 1:n_iter){
b_exper <- rnorm(n_exper, mean = 0, sd = sigma_exper)
b_exper_col <- rep(rep(b_exper, each = n_dish * n_cell), n_treat)
# length(b_exper_col)
b_batch <- rnorm(t_batch, mean = 0, sd = sigma_batch)
b_batch_col <- rep(b_batch, each = n_dish * n_cell)
# length(b_batch_col)
b_dish <- rnorm(t_dish, mean = 0, sd = sigma_dish)
b_dish_col <- rep(b_dish, each = n_cell)
# length(b_dish_col)
b_cell_col <- rnorm(t_cell, mean = 0, sd = sigma_cell)
# length(b_cell_col)
# put it all together
fd[, y := b_treat_col + b_exper_col + b_batch_col + b_dish_col + b_cell_col]
# lm of raw data
m1 <- lm(y ~ treatment, data = fd)
m1_pairs <- emmeans(m1, specs = "treatment") |>
contrast(method = "revpairwise", adjust = "none") |>
summary()
p1_m1[iter] <- m1_pairs[1, "p.value"]
p2_m1[iter] <- m1_pairs[5, "p.value"]
# lm of control centered data
exper_means <- fd[, .(y_bar = mean(y)), by = .(treatment, experiment)]
y_bar_vec <- rep(rep(exper_means[1:4, y_bar], each = n_cell * n_dish), 4)
fd[, y_c := y/y_bar_vec]
# fd[, .(mean = mean(y_c),
#        sd = sd(y_c)), by = .(treatment, experiment)]
m2 <- lm(y_c ~ treatment, data = fd)
m2_pairs <- emmeans(m2, specs = "treatment") |>
contrast(method = "revpairwise", adjust = "none") |>
summary()
p1_m2[iter] <- m2_pairs[1, "p.value"]
p2_m2[iter] <- m2_pairs[5, "p.value"]
# lmm models
lmm1 <- lmer(y ~ treatment + (1 | experiment) + (1 | batch) + (1 | dish), data = fd)
lmm1_pairs <- emmeans(lmm1, specs = "treatment") |>
contrast(method = "revpairwise", adjust = "none") |>
summary()
p1_lmm1[iter] <- lmm1_pairs[1, "p.value"]
p2_lmm1[iter] <- lmm1_pairs[5, "p.value"]
# RM-ANOVA models
aov1 <- aov_4(y ~ treatment + (treatment | experiment), data = fd, fun_aggregate = mean)
aov1_pairs <- emmeans(aov1, specs = "treatment") |>
contrast(method = "revpairwise", adjust = "none") |> summary()
p1_aov1[iter] <- aov1_pairs[1, "p.value"]
p2_aov1[iter] <- aov1_pairs[5, "p.value"]
}
type_1_matrix <- rbind(
type_1_matrix,
data.table(
resid_frac = residual_frac_i,
"sigma_cell" = sigma_cell, # among cells within a dish - this is residual
"sigma_exper" = sigma_exper, # among experiments
"sigma_batch" = sigma_batch, # among batches within a treatment:experiment
"sigma_dish" = sigma_dish, # among dishes within a treatment:experiment:batch
"p1_m1" = p1_m1,
"p2_m1" = p2_m1,
"p1_m2" = p1_m2,
"p2_m2" = p2_m2,
"p1_lmm1" = p1_lmm1,
"p2_lmm1" = p2_lmm1,
# "p1_lmm2" = p1_lmm2,
# "p2_lmm2" = p2_lmm2,
"p1_aov1" = p1_aov1,
"p2_aov1" = p2_aov1
)
)
}
saveRDS(type_1_matrix, "type_1_matrix.Rds")
}else{
type_1_matrix <- readRDS("type_1_matrix.Rds")
}
residual_frac_list <- unique(type_1_matrix$resid_frac)
param_mat <- expand.grid(residual_frac = residual_frac_list)
param_mat$icc <- NA
param_mat$lm1_p1 <- NA
param_mat$lm1_p2 <- NA
param_mat$lm2_p1 <- NA
param_mat$lm2_p2 <- NA
param_mat$lmm1_p1 <- NA
param_mat$lmm1_p2 <- NA
param_mat$rmaov_p1 <- NA
param_mat$rmaov_p2 <- NA
for(param_set in 1:nrow(param_mat)){
residual_frac_i <- param_mat[param_set, "residual_frac"] # fraction of random variance that is unmodeled noise
random_var <-
type_1_matrix[resid_frac == residual_frac_i, sigma_exper][1]^2 +
type_1_matrix[resid_frac == residual_frac_i, sigma_batch][1]^2 +
type_1_matrix[resid_frac == residual_frac_i, sigma_dish][1]^2
total_var <- random_var +
type_1_matrix[resid_frac == residual_frac_i, sigma_cell][1]^2
param_mat[param_set, "icc"] <- random_var/total_var
p1_m1 <- type_1_matrix[resid_frac == residual_frac_i, p1_m1]
p2_m1 <- type_1_matrix[resid_frac == residual_frac_i, p2_m1]
p1_m2 <- type_1_matrix[resid_frac == residual_frac_i, p1_m2]
p2_m2 <- type_1_matrix[resid_frac == residual_frac_i, p2_m2]
p1_lmm1 <- type_1_matrix[resid_frac == residual_frac_i, p1_lmm1]
p2_lmm1 <- type_1_matrix[resid_frac == residual_frac_i, p2_lmm1]
p1_aov1 <- type_1_matrix[resid_frac == residual_frac_i, p1_aov1]
p2_aov1 <- type_1_matrix[resid_frac == residual_frac_i, p2_aov1]
n_iter <- length(p1_m1)
param_mat[param_set, "lm1_p1"] <- sum(p1_m1 < 0.05)/n_iter
param_mat[param_set, "lm1_p2"] <- sum(p2_m1 < 0.05)/n_iter
param_mat[param_set, "lmm1_p1"] <- sum(p1_lmm1 < 0.05)/n_iter
param_mat[param_set, "lmm1_p2"] <- sum(p2_lmm1 < 0.05)/n_iter
param_mat[param_set, "lm2_p1"] <- sum(p1_m2 < 0.05)/n_iter
param_mat[param_set, "lm2_p2"] <- sum(p2_m2 < 0.05)/n_iter
param_mat[param_set, "rmaov_p1"] <- sum(p1_aov1 < 0.05)/n_iter
param_mat[param_set, "rmaov_p2"] <- sum(p2_aov1 < 0.05)/n_iter
}
param_mat |>
kable(digits = c(2,3,2,3,3,3,3,3,3)) |>
kable_styling()
